@execute

123, 123
"return 123", 123
"123 + 456", 579
"'hello' $ ' ' $ 'world'", "'hello world'"
"1 + 2 * 3", "7"
"a = 2; -a", "-2"
"a = true; not a", false
"x = 123; y = 456; x + y", 579

"1000 is 1e3"
"1e3 is 1000"
"10e3 is 1e4"
".001 is 0.001"

"a = 0; ++a", 1
"a = 0; a++", 0
"a = 0; a++; a", 1
"a = 0; --a", -1
"a = 0; a--", 0
"a = 0; a--; a", -1

"Suneido.a = 0; ++Suneido.a", 1
"Suneido.a = 0; Suneido.a++", 0
"Suneido.a = 0; Suneido.a++; Suneido.a", 1
"Suneido.a = 0; --Suneido.a", -1
"Suneido.a = 0; Suneido.a--", 0
"Suneido.a = 0; Suneido.a--; Suneido.a", -1

"Suneido[0] = 0; ++Suneido[0]", 1
"Suneido[0] = 0; Suneido[0]++", 0
"Suneido[0] = 0; Suneido[0]++; Suneido[0]", 1
"Suneido[0] = 0; --Suneido[0]", -1
"Suneido[0] = 0; Suneido[0]--", "0"
"Suneido[0] = 0; Suneido[0]--; Suneido[0]", -1

// integer
"2 < 3", true
"3 < 2", false
"2 < 2", false

// dnum
"1.1 < 1.2", true
"1.2 < 1.1", false

// integer & dnum
".5 < 99", true
"99 < .5", false

// object
"#(.5) < #(99)", true
"#(99) < #(.5)", false

"2 <= 3", true
"3 <= 2", false
"2 <= 2", true

"2 > 3", false
"3 > 2", true
"2 > 2", false

"2 >= 3", false
"3 >= 2", true
"2 >= 2", true

// string
"'' < 'a'", true
"'a' < 'b'", true
"'ab' < 'abc'", true
"'aba' < 'abc'", true

"'abc' =~ '^[a-c]+$'", true
"'abcx' !~ '^[a-c]+$'", true

"s = 1; s $= 2", "'12'"
"n = 10; n -= 5", 5

"t = true; f = false; t and t", true
"t = true; f = false; t and f", false
"t = true; f = false; f and t", false
"t = true; f = false; f and f", false
"t = true; f = false; t or t", true
"t = true; f = false; t or f", true
"t = true; f = false; f or t", true
"t = true; f = false; f or f", false

"x = true; x ? 1 : 2", 1
"x = false; x ? 1 : 2", 2

"0 in (1,2,3)", false
"1 in (1,2,3)", true
"2 in (1,2,3)", true
"3 in (1,2,3)", true
"0 not in (1,2,3)", true
"1 not in (1,2,3)", false
"2 not in (1,2,3)", false
"3 not in (1,2,3)", false

"i = 0; while i < 4 { ++i } i", 4

"x = 4; if x > 3 { return 1 } else { return -1 }", 1
"x = 2; if x > 3 { return 1 } else { return -1 }", -1

"x = 2
switch {
case x < 3: return -1
case x is 3: return 0
case x > 3: return +1
}", -1

"x = 3
switch {
case x < 3: return -1
case x is 3: return 0
case x > 3: return +1
}", 0

"x = 4
switch {
case x < 3: return -1
case x is 3: return 0
case x > 3: return +1
}", 1

"x = 4
switch x {
case 3: return 0
default: return 1
}", 1

"s='hello'; s[0]", 'h'
"s='hello'; s[4]", 'o'
"s='hello'; s[9]", "''"
"s='hello'; s[-1]", 'o' // end relative
"s='hello'; s[-5]", 'h' // end relative
"s='hello'; s[-6]", "''"

"x=#(1,2,3); x[0]", 1
"x=#(1,2,3); x[2]", 3
"x=#(1,2,3); x[3]" throws "uninitialized member: 3"
"x=#(1,2,3); x[-1]" throws "uninitialized member: -1"

// int vs dnum index
"Suneido[1]=123; Suneido[.5 + .5]", 123
"Suneido[1.5 + .5]=456; Suneido[2]", 456

// only "" and false should convert to number or integer

// convert to number - folding
"123 + ''", 123
"123 + false", 123
"-true" throws "can't convert true to number"
"123 + true" throws "can't convert true to number"
"123 + '111'" throws "can't convert String to number"
// convert to number
"x = 123; x + ''", 123
"x = 123; x + false", 123
"x = true; -x" throws "can't convert true to number"
"x = 123; x + true" throws "can't convert true to number"
"x = 123; x + '111'" throws "can't convert String to number"
// convert to integer - folding
"0xff & 0xf", 0xf
"~true" throws "can't convert true to integer"
"0xff & true" throws "can't convert true to integer"
"0xff & '1'" throws "can't convert String to integer"
"4.8 % 2" throws "can't convert number to integer"
// convert to integer
"x = 0xff; x & 0xf", 0xf
"x = true; ~x" throws "can't convert true to integer"
"x = 0xff; x & true" throws "can't convert true to integer"
"x = 0xff; x & '1'" throws "can't convert String to integer"
"x = 4.8; x % 2" throws "can't convert number to integer"

"s = 'hello'; s[1.2]" throws "indexes must be integers"
"s = 'hello'; s['']" throws "indexes must be integers"
"s = 'hello'; s[false]" throws "indexes must be integers"
"s = 'hello'; s['' ..]" throws "indexes must be integers"
"s = 'hello'; s[false ..]" throws "indexes must be integers"
"s = 'hello'; s['' ::]" throws "indexes must be integers"
"s = 'hello'; s[false ::]" throws "indexes must be integers"
"x = #(); x['' ::]" throws "indexes must be integers"
"x = #(); x[false ::]" throws "indexes must be integers"

"x = Object(1,2,3); x[0::2]", "#(1,2)"
"x = Object(3); x[0::1][0] = 9; x", "#(3)"

@execute // argument handling
"Object().Add(@Seq(1000)).Size()", 1000 //  // Add(@ shouldn't expand onto stack

"Object(a: 123).Eval(function (x) { x * .a }, 10)", 1230
"Object(a: 123).Eval(@#(function (x) { x * .a }, 10))", 1230

"Object(a: 1, a: 2)" throws "duplicate argument name"

"a=1; Object(:a)", "#(a: 1)"

"a=1; Object([:a])", "#((a: 1))"
"b=1; Object(a: [:b])", "#(a: [b: 1])"
"Object(@#(1, 2, a: 3, b: 4))", "#(1, 2, a: 3, b: 4)"
"Object(@+1#(1, 2, a: 3, b: 4))", "#(2, a: 3, b: 4)"
"Record(@#(1, 2, a: 3, b: 4))", "#{1, 2, a: 3, b: 4}"
"Record(@+1#(1, 2, a: 3, b: 4))", "#{2, a: 3, b: 4}"

@execute // unary plus and minus conversions
// fold
"+true" throws "can't convert true to number"
"+false", 0
"-true" throws "can't convert true to number"
"-false", 0
// execute
"x = true; +x" throws "can't convert true to number"
"x = false; +x", 0
"x = true; -x" throws "can't convert true to number"
"x = false; -x", 0

@execute // calls

// different numbers of arguments
"function(){123}()", 123
"function(a){a}(123)", 123
"function(a,b){a+b}(1,2)", 3
"function(a,b,c){a+b+c}(1,2,3)", 6
"function(a,b,c,d){a+b+c+d}(1,2,3,4)", 10
"function(a,b,c,d,e){a+b+c+d+e}(1,2,3,4,5)", 15

// CallClass
"class{CallClass(){123}}()", 123
"class{CallClass(a){a}}(123)", 123
"class{CallClass(a,b){a+b}}(1,2)", 3
"class{CallClass(a,b,c){a+b+c}}(1,2,3)", 6
"class{CallClass(a,b,c,d){a+b+c+d}}(1,2,3,4)", 10
"class{CallClass(a,b,c,d,e){a+b+c+d+e}}(1,2,3,4,5)", 15

// class "static" method
"class{M(){123}}.M()", 123
"class{M(a){a}}.M(123)", 123
"class{M(a,b){a+b}}.M(1,2)", 3
"class{M(a,b,c){a+b+c}}.M(1,2,3)", 6
"class{M(a,b,c,d){a+b+c+d}}.M(1,2,3,4)", 10
"class{M(a,b,c,d,e){a+b+c+d+e}}.M(1,2,3,4,5)", 15

// access to "this"
"class{X: 123}.X", 123
"class{M(){.X} X: 123}.M()", 123
"class{M(){.x} x: 123}.M()", 123
"class{CallClass(){.x} x: 123}()", 123

// no params
"function(){123}()", 123
"function(){123}(a: 1)", 123
"function(){123}(a: 1, b: 2)", 123
"function(){123}(@#())", 123
"function(){123}(@#(a: 1, b: 2))", 123
"function(){123}(@+1#())", 123
"function(){123}(@+1#(a: 1, b: 2))", 123
"function(){123}(1)" throws "too many arguments"

// @param
"function(@x){x}(123)", "#(123)"
"function(@x){x}(1,2,3)", "#(1, 2, 3)"
"function(@x){x}(1,2,a:3,b:4)", "#(1, 2, a: 3, b: 4)"

// some params
"function(a,b){a+b}()" throws "missing argument"
"function(a,b){a+b}(1)" throws "missing argument"
"function(a,b){a+b}(1,2)", 3
"function(a,b){a+b}(@#(1,2))", 3
"function(a,b){a+b}(@+1#(1,2,3))", 5
"function(a,b){a+b}(@#(1,2,x:3,y:4))", 3
"function(a,b){a+b}(1,2,3)" throws "too many arguments"
"function(a,b){a+b}(@#(1,2,3))" throws "too many arguments"

// dynamic param defaults
"_a=1; _b=2; function(_a,_b){[a,b]}()", "[1,2]"
"_a=1; _b=2; function(_a,_b){[a,b]}(3)", "[3,2]"
"_a=1; _b=2; function(_a,_b){[a,b]}(3,4)", "[3,4]"

@execute // naming

// test Def compiles string
"Def(#Foo, 'function(){}')
Type(Foo)", "'Function'"

"foo = function(){}
Name(foo)", "foo"

"c = class { Foo(){} }
Name(c.Foo).Has?('.Foo')"

"Def(#Foo, 'function(){}')
Name(Foo)", "Foo"

"Def(#Foo, 'class{}')
Name(Foo)", "Foo"

@execute // privatization

"Def(#Foo, 'class { x: 123 }')
Foo.Foo_x", 123

"Def(#Foo, 'class { f(){ 123 } }')
Foo.Foo_f()", 123

"Def(#Foo, 'class { F(x){ .x = x } }')
ob = Foo()
ob.F(123)
ob.Foo_x", 123

"Def(#Foo, 'class { F(.x){ } }')
ob = Foo()
ob.F(123)
ob.Foo_x", 123
